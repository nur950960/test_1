'===============  Принципы ООП ==============='
# Наследование 
# Инкапсуляция 
# Полиморфизм 
# Абстракция 
# Ассоциация - Композиция, Агрегация 

'=============== Наследование =================' 

# Наследование - это принцип ООП, в котором мы можем унаследовать, переопределять и использовать в дочернем классе все аттрибуты и методы 2родительского класса 

# class A: 
#     def method(self): 
#         print('Метод класса A') 

# obj_A = A() 
# obj_A.method()

# class B(A): 
    # '''
    # Наследовали все методы и аттрибуты родительского класса А 
    # '''

# obj_B = B() 
# obj_B.method()

# class C(A): 
#     def method(self):
#         print('Метод в классе C') 

# obj_C = C() 
# obj_C.method()
'------------------------'
# class A: 
#     x = 'x в классе A'
#     y = 'y в классе A' 

# class B(A): 
#     x = 'x в классе B'

# print(A.x) # x в классе A 
# print(A.y) # y в классе A 

# print(B.x) # x в классе B 
# print(B.y) # y в классе A 
'-------------------------'
'mro (method resulition order) - порядок поиска аттрибутов' 

# class A: 
#     ...

# class B(A): 
#     ... 

# print(B.mro()) # <class '__main__.B'>, <class '__main__.A'>, <class 'object'>]
'------------------------'
# class A: 
#     def my_range(self, n): 
#         return list(range(n + 1)) 
    
# class B(A): 
#     def my_range(self, n): 
#         list_ = super().my_range(n)
#         list_.append(0) 
#         return list_
    
# print(B().my_range(10)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0] 

'super() - это функция благодаря которой мы можем обращаться к родительскому классу'

'=================== Виды наследования ================='
# одиночное наследование (когда мы наследуем в дочернем классе от 1 класса )
# множественное наследование (когда мы наследуемся в дочернем классе от нескольких родительских)
# многоуровневое нвследование (когда мы наследуемся от класса у которых есть родитель) 
# иерархическое наследование (когда от одного родителя много дочерних классов)
# гибридное наследование (когда испльзуется несколько видов наследование)

'----- Проблемы множественного наследования -----'
# Проблема Ромба (Алмазная проблема)

# class A: 
#     def __str__(self): 
#         return 'A' 
    
# class B: 
#     def __str__(self): 
#         return 'B' 
    
# class C(A, B): 
#     ... 

# obj_C = C() 
# print(obj_C)

# print(C.mro())
#проблема перекрестного наследование (не решена) 
'-------------------------'
# class A:
#     ... 
# class B: 
#     ... 

# class E(A,B): 
#     ... 
# class D(B,A): 
#     ... 

# class F(E,D): 
#     ...
'-------------------------'